{"ast":null,"code":"import _regeneratorRuntime from \"G:/FYP/LostNestfyp/lostnestprj/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"G:/FYP/LostNestfyp/lostnestprj/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { MongoClient } from \"mongodb\";\n\nvar _require = require(\"mongodb\"),\n    ObjectId = _require.ObjectId;\n\nvar cachedClient = null;\nvar clientSet = false;\nexport function connectToDatabase() {\n  return _connectToDatabase.apply(this, arguments);\n}\n\nfunction _connectToDatabase() {\n  _connectToDatabase = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var client, connectionString;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!clientSet) {\n              _context.next = 3;\n              break;\n            }\n\n            console.log(\"return already stored client\");\n            return _context.abrupt(\"return\", cachedClient);\n\n          case 3:\n            connectionString = \"mongodb+srv://\".concat(process.env.mongodb_username, \":\").concat(process.env.mongodb_password, \"@\").concat(process.env.mongodb_clustername, \".psik2ae.mongodb.net/\").concat(process.env.mongodb_database, \"?retryWrites=true&w=majority\");\n            _context.prev = 4;\n            _context.next = 7;\n            return MongoClient.connect(connectionString, {\n              useUnifiedTopology: true,\n              useNewUrlParser: true,\n              connectTimeoutMS: 30000,\n              poolSize: 10 // Adjust this based on your application's needs\n\n            });\n\n          case 7:\n            client = _context.sent;\n            _context.next = 13;\n            break;\n\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context[\"catch\"](4);\n            console.error(\"Error connecting to the database:\", _context.t0);\n\n          case 13:\n            // Handle the 'close' event for potential reconnection\n            client.on(\"close\", function () {\n              console.log(\"Connection closed. Reconnecting...\"); // Implement reconnection logic here, such as calling connectToDatabase()\n\n              connectToDatabase(); //client.connect();\n            });\n\n            if (!clientSet) {\n              cachedClient = client;\n              clientSet = true;\n              console.log(\"return new client\");\n            }\n\n            return _context.abrupt(\"return\", client);\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 10]]);\n  }));\n  return _connectToDatabase.apply(this, arguments);\n}\n\nexport function getAllPosts() {\n  return _getAllPosts.apply(this, arguments);\n}\n\nfunction _getAllPosts() {\n  _getAllPosts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var client, db, data;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return connectToDatabase();\n\n          case 2:\n            client = _context2.sent;\n            db = client.db();\n            _context2.next = 6;\n            return db.collection(\"PostedItem\").find({}).toArray();\n\n          case 6:\n            data = _context2.sent;\n            return _context2.abrupt(\"return\", data);\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getAllPosts.apply(this, arguments);\n}\n\nexport function getPostDataById(_x) {\n  return _getPostDataById.apply(this, arguments);\n}\n\nfunction _getPostDataById() {\n  _getPostDataById = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(id) {\n    var client, usersCollection, postobjectId, user;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return connectToDatabase();\n\n          case 2:\n            client = _context3.sent;\n            usersCollection = client.db().collection(\"PostedItem\");\n            postobjectId = new ObjectId(id);\n            _context3.next = 7;\n            return usersCollection.findOne({\n              _id: postobjectId\n            });\n\n          case 7:\n            user = _context3.sent;\n            return _context3.abrupt(\"return\", user);\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getPostDataById.apply(this, arguments);\n}\n\nexport function getResponseDataById(_x2) {\n  return _getResponseDataById.apply(this, arguments);\n}\n\nfunction _getResponseDataById() {\n  _getResponseDataById = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(id) {\n    var client, usersCollection, user;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return connectToDatabase();\n\n          case 2:\n            client = _context4.sent;\n            usersCollection = client.db().collection(\"QAnswers\");\n            _context4.next = 6;\n            return usersCollection.find({\n              PostID: id\n            }).toArray();\n\n          case 6:\n            user = _context4.sent;\n            return _context4.abrupt(\"return\", user);\n\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getResponseDataById.apply(this, arguments);\n}\n\nexport function fetchallemails() {\n  return _fetchallemails.apply(this, arguments);\n}\n\nfunction _fetchallemails() {\n  _fetchallemails = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var client, usersCollection, allemails;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return connectToDatabase();\n\n          case 2:\n            client = _context5.sent;\n            usersCollection = client.db().collection(\"users\");\n            _context5.next = 6;\n            return usersCollection.find({}, {\n              projection: {\n                password: 0,\n                name: 0,\n                _id: 0\n              }\n            }).toArray();\n\n          case 6:\n            allemails = _context5.sent;\n            return _context5.abrupt(\"return\", allemails);\n\n          case 8:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _fetchallemails.apply(this, arguments);\n}\n\nexport function countTotalPosts() {\n  return _countTotalPosts.apply(this, arguments);\n} // export async function getProfileData(userEmail) {\n//   const client = await connectToDatabase();\n//   const usersCollection = client.db().collection(\"users\");\n//   const user = await usersCollection.findOne(\n//     { email: userEmail },\n//     { projection: { password: 0 } }\n//   );\n//   return user;\n// }\n// import { MongoClient } from \"mongodb\";\n// const { ObjectId } = require(\"mongodb\");\n// let cachedClient = null;\n// let clientSet = false;\n// export async function connectToDatabase() {\n//   if (clientSet) {\n//     console.log(\"return already stored client\" + cachedClient);\n//     return cachedClient;\n//   }\n//   let client;\n//   const connectionString = `mongodb+srv://${process.env.mongodb_username}:${process.env.mongodb_password}@${process.env.mongodb_clustername}.psik2ae.mongodb.net/${process.env.mongodb_database}?retryWrites=true&w=majority`;\n//   client = await MongoClient.connect(connectionString, {\n//     useUnifiedTopology: true,\n//     useNewUrlParser: true,\n//     connectTimeoutMS: 30000,\n//   });\n//   if (!clientSet) {\n//     cachedClient = client;\n//     clientSet = true;\n//     console.log(\"return new client\");\n//   }\n//   return client;\n// }\n\n/*\n\n\nimport { MongoClient } from \"mongodb\";\nconst { ObjectId } = require(\"mongodb\");\n\nlet cachedClient = null;\nlet clientSet = false;\n\nexport async function connectToDatabase() {\n  if (clientSet) {\n    console.log(\"return already stored client\" + cachedClient);\n    return cachedClient;\n  }\n\n  const client = await MongoClient.connect(\n    \"mongodb+srv://ghufran:Allahis1@cluster0.psik2ae.mongodb.net/authSec14?retryWrites=true&w=majority\",\n    {\n      useUnifiedTopology: true,\n      useNewUrlParser: true,\n      connectTimeoutMS: 30000,\n    }\n  );\n\n  if (!clientSet) {\n    cachedClient = client;\n    clientSet = true;\n    console.log(\"return new client\");\n  }\n\n  return client;\n}\n\n\n*/\n// export async function getPostsByEmail(email) {\n//   //console.log(email);\n//   const allPosts = await getAllPosts();\n//   //console.log(allPosts);\n//   // return allPosts.find((event) => event.posterEmail === email);\n//   return allPosts.filter((event) => event.posterEmail === email);\n// }\n// export async function getPostDataById(id) {\n//   const allPosts = await getAllPosts(); //w\n//   const postobjectId = new ObjectId(id);\n//   //console.log(postobjectId);\n//   // return allPosts.find((event) => event._id === postobjectId);\n//   return allPosts.find(\n//     (event) => event._id.toString() === postobjectId.toString()\n//   );\n// }\n// export async function getResponseDataById(id) {\n//   const client = await connectToDatabase();\n//   const db = client.db();\n//   const data = await db.collection(\"QAnswers\").find({}).toArray();\n//   //console.log(data);\n//   return data.filter((event) => event.PostID === id);\n// }\n// export async function getPostsByObjectId(objectId) {\n//   const allPosts = await getAllPosts();\n//   //console.log(allPosts); good\n//   console.log(objectId);\n//   const data2 = allPosts.find((item) => item._id.equals(objectId));\n//   console.log(data2);\n//   return data2;\n// }\n// import { ObjectId } from \"mongodb\";\n// export async function getPostsByObjectId(objectId) {\n//   const allPosts = await getAllPosts();\n//   const data2 = allPosts.find((item) => item._id.equals(objectId));\n//   console.log(data2);\n//   return data2;\n// }\n// import { MongoClient } from \"mongodb\";\n// const { ObjectId } = require(\"mongodb\");\n// class Database {\n//   constructor() {\n//     if (!Database.instance) {\n//       this.client = null;\n//       this.clientSet = false;\n//       Database.instance = this;\n//     }\n//     return Database.instance;\n//   }\n//   async connect() {\n//     if (this.clientSet) {\n//       console.log(\"return already stored client\");\n//       return this.client;\n//     }\n//     this.client = await MongoClient.connect(\n//       \"mongodb+srv://ghufran:Allahis1@cluster0.psik2ae.mongodb.net/authSec14?retryWrites=true&w=majority\",\n//       {\n//         useUnifiedTopology: true,\n//         useNewUrlParser: true,\n//         connectTimeoutMS: 30000,\n//       }\n//     );\n//     if (!this.clientSet) {\n//       this.clientSet = true;\n//       console.log(\"return new client\");\n//     }\n//     return this.client;\n//   }\n// }\n// const database = new Database();\n// export const connectToDatabase = async () => {\n//   try {\n//     return await database.connect();\n//   } catch (error) {\n//     //console.error(\"Error connecting to the database:\", error);\n//     throw error;\n//   }\n// };\n\nfunction _countTotalPosts() {\n  _countTotalPosts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n    var client, postedItemCollection, totalPosts;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return connectToDatabase();\n\n          case 2:\n            client = _context6.sent;\n            postedItemCollection = client.db().collection(\"PostedItem\");\n            _context6.next = 6;\n            return postedItemCollection.countDocuments();\n\n          case 6:\n            totalPosts = _context6.sent;\n            console.log(totalPosts);\n            return _context6.abrupt(\"return\", totalPosts);\n\n          case 9:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _countTotalPosts.apply(this, arguments);\n}","map":{"version":3,"sources":["G:/FYP/LostNestfyp/lostnestprj/lib/db.js"],"names":["MongoClient","require","ObjectId","cachedClient","clientSet","connectToDatabase","console","log","connectionString","process","env","mongodb_username","mongodb_password","mongodb_clustername","mongodb_database","connect","useUnifiedTopology","useNewUrlParser","connectTimeoutMS","poolSize","client","error","on","getAllPosts","db","collection","find","toArray","data","getPostDataById","id","usersCollection","postobjectId","findOne","_id","user","getResponseDataById","PostID","fetchallemails","projection","password","name","allemails","countTotalPosts","postedItemCollection","countDocuments","totalPosts"],"mappings":"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,mBAKmBM,eAAe,CACpCL,IADqB,CAChB,EADgB,EACZ;AAAEa,cAAAA,UAAU,EAAE;AAAEC,gBAAAA,QAAQ,EAAE,CAAZ;AAAeC,gBAAAA,IAAI,EAAE,CAArB;AAAwBP,gBAAAA,GAAG,EAAE;AAA7B;AAAd,aADY,EAErBP,OAFqB,EALnB;;AAAA;AAKCe,YAAAA,SALD;AAAA,8CASEA,SATF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAYP,gBAAsBC,eAAtB;AAAA;AAAA,C,CAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;8EAnLO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACgBtC,iBAAiB,EADjC;;AAAA;AACCe,YAAAA,MADD;AAGCwB,YAAAA,oBAHD,GAGwBxB,MAAM,CAACI,EAAP,GAAYC,UAAZ,CAAuB,YAAvB,CAHxB;AAAA;AAAA,mBAIoBmB,oBAAoB,CAACC,cAArB,EAJpB;;AAAA;AAICC,YAAAA,UAJD;AAKLxC,YAAAA,OAAO,CAACC,GAAR,CAAYuC,UAAZ;AALK,8CAOEA,UAPF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["import { MongoClient } from \"mongodb\";\nconst { ObjectId } = require(\"mongodb\");\nlet cachedClient = null;\nlet clientSet = false;\n\nexport async function connectToDatabase() {\n  if (clientSet) {\n    console.log(\"return already stored client\");\n    return cachedClient;\n  }\n\n  let client;\n\n  const connectionString = `mongodb+srv://${process.env.mongodb_username}:${process.env.mongodb_password}@${process.env.mongodb_clustername}.psik2ae.mongodb.net/${process.env.mongodb_database}?retryWrites=true&w=majority`;\n\n  try {\n    client = await MongoClient.connect(connectionString, {\n      useUnifiedTopology: true,\n      useNewUrlParser: true,\n      connectTimeoutMS: 30000,\n      poolSize: 10, // Adjust this based on your application's needs\n    });\n  } catch (error) {\n    console.error(\"Error connecting to the database:\", error);\n  }\n\n  // Handle the 'close' event for potential reconnection\n  client.on(\"close\", () => {\n    console.log(\"Connection closed. Reconnecting...\");\n    // Implement reconnection logic here, such as calling connectToDatabase()\n    connectToDatabase();\n    //client.connect();\n  });\n\n  if (!clientSet) {\n    cachedClient = client;\n    clientSet = true;\n    console.log(\"return new client\");\n  }\n\n  return client;\n}\n\nexport async function getAllPosts() {\n  const client = await connectToDatabase();\n  const db = client.db();\n\n  const data = await db.collection(\"PostedItem\").find({}).toArray();\n\n  return data;\n}\n\nexport async function getPostDataById(id) {\n  const client = await connectToDatabase();\n  const usersCollection = client.db().collection(\"PostedItem\");\n  const postobjectId = new ObjectId(id);\n\n  const user = await usersCollection.findOne({\n    _id: postobjectId,\n  });\n\n  return user;\n}\n\nexport async function getResponseDataById(id) {\n  const client = await connectToDatabase();\n\n  const usersCollection = client.db().collection(\"QAnswers\");\n\n  const user = await usersCollection\n    .find({\n      PostID: id,\n    })\n    .toArray();\n  return user;\n}\n\nexport async function fetchallemails() {\n  const client = await connectToDatabase();\n\n  const usersCollection = client.db().collection(\"users\");\n\n  const allemails = await usersCollection\n    .find({}, { projection: { password: 0, name: 0, _id: 0 } })\n    .toArray();\n\n  return allemails;\n}\n\nexport async function countTotalPosts() {\n  const client = await connectToDatabase();\n\n  const postedItemCollection = client.db().collection(\"PostedItem\");\n  const totalPosts = await postedItemCollection.countDocuments();\n  console.log(totalPosts);\n\n  return totalPosts;\n}\n\n// export async function getProfileData(userEmail) {\n//   const client = await connectToDatabase();\n//   const usersCollection = client.db().collection(\"users\");\n//   const user = await usersCollection.findOne(\n//     { email: userEmail },\n//     { projection: { password: 0 } }\n//   );\n\n//   return user;\n// }\n\n// import { MongoClient } from \"mongodb\";\n// const { ObjectId } = require(\"mongodb\");\n\n// let cachedClient = null;\n// let clientSet = false;\n\n// export async function connectToDatabase() {\n//   if (clientSet) {\n//     console.log(\"return already stored client\" + cachedClient);\n//     return cachedClient;\n//   }\n\n//   let client;\n\n//   const connectionString = `mongodb+srv://${process.env.mongodb_username}:${process.env.mongodb_password}@${process.env.mongodb_clustername}.psik2ae.mongodb.net/${process.env.mongodb_database}?retryWrites=true&w=majority`;\n\n//   client = await MongoClient.connect(connectionString, {\n//     useUnifiedTopology: true,\n//     useNewUrlParser: true,\n//     connectTimeoutMS: 30000,\n//   });\n\n//   if (!clientSet) {\n//     cachedClient = client;\n//     clientSet = true;\n//     console.log(\"return new client\");\n//   }\n\n//   return client;\n// }\n\n/*\n\n\nimport { MongoClient } from \"mongodb\";\nconst { ObjectId } = require(\"mongodb\");\n\nlet cachedClient = null;\nlet clientSet = false;\n\nexport async function connectToDatabase() {\n  if (clientSet) {\n    console.log(\"return already stored client\" + cachedClient);\n    return cachedClient;\n  }\n\n  const client = await MongoClient.connect(\n    \"mongodb+srv://ghufran:Allahis1@cluster0.psik2ae.mongodb.net/authSec14?retryWrites=true&w=majority\",\n    {\n      useUnifiedTopology: true,\n      useNewUrlParser: true,\n      connectTimeoutMS: 30000,\n    }\n  );\n\n  if (!clientSet) {\n    cachedClient = client;\n    clientSet = true;\n    console.log(\"return new client\");\n  }\n\n  return client;\n}\n\n\n*/\n// export async function getPostsByEmail(email) {\n//   //console.log(email);\n//   const allPosts = await getAllPosts();\n//   //console.log(allPosts);\n//   // return allPosts.find((event) => event.posterEmail === email);\n//   return allPosts.filter((event) => event.posterEmail === email);\n// }\n// export async function getPostDataById(id) {\n//   const allPosts = await getAllPosts(); //w\n\n//   const postobjectId = new ObjectId(id);\n//   //console.log(postobjectId);\n\n//   // return allPosts.find((event) => event._id === postobjectId);\n//   return allPosts.find(\n//     (event) => event._id.toString() === postobjectId.toString()\n//   );\n// }\n// export async function getResponseDataById(id) {\n//   const client = await connectToDatabase();\n//   const db = client.db();\n\n//   const data = await db.collection(\"QAnswers\").find({}).toArray();\n\n//   //console.log(data);\n//   return data.filter((event) => event.PostID === id);\n// }\n\n// export async function getPostsByObjectId(objectId) {\n//   const allPosts = await getAllPosts();\n\n//   //console.log(allPosts); good\n//   console.log(objectId);\n//   const data2 = allPosts.find((item) => item._id.equals(objectId));\n//   console.log(data2);\n//   return data2;\n// }\n// import { ObjectId } from \"mongodb\";\n\n// export async function getPostsByObjectId(objectId) {\n//   const allPosts = await getAllPosts();\n\n//   const data2 = allPosts.find((item) => item._id.equals(objectId));\n//   console.log(data2);\n//   return data2;\n// }\n\n// import { MongoClient } from \"mongodb\";\n// const { ObjectId } = require(\"mongodb\");\n// class Database {\n//   constructor() {\n//     if (!Database.instance) {\n//       this.client = null;\n//       this.clientSet = false;\n//       Database.instance = this;\n//     }\n\n//     return Database.instance;\n//   }\n\n//   async connect() {\n//     if (this.clientSet) {\n//       console.log(\"return already stored client\");\n//       return this.client;\n//     }\n\n//     this.client = await MongoClient.connect(\n//       \"mongodb+srv://ghufran:Allahis1@cluster0.psik2ae.mongodb.net/authSec14?retryWrites=true&w=majority\",\n//       {\n//         useUnifiedTopology: true,\n//         useNewUrlParser: true,\n//         connectTimeoutMS: 30000,\n//       }\n//     );\n\n//     if (!this.clientSet) {\n//       this.clientSet = true;\n//       console.log(\"return new client\");\n//     }\n\n//     return this.client;\n//   }\n// }\n\n// const database = new Database();\n// export const connectToDatabase = async () => {\n//   try {\n//     return await database.connect();\n//   } catch (error) {\n//     //console.error(\"Error connecting to the database:\", error);\n//     throw error;\n//   }\n// };\n"]},"metadata":{},"sourceType":"module"}